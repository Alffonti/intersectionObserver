<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TOC with scroll highlighting</title>
    <link rel="stylesheet" href="./style.css" />
    <script src="./script.js" defer></script>
  </head>
  <body>
    <!--suppress ALL -->
    <header class="header">
      <h1>TOC with scroll highlighting</h1>
    </header>
    <main class="content-container">
      <aside class="content-sidebar">
        <nav class="content-navigation">
          <header>
            <h2 class="content-navigation-title">Navigation</h2>
          </header>
          <a href="#section-Intersection_observer_concepts_and_usage">
            Intersection observer concepts and usage
          </a>

          <a href="#section-Creating_an_intersection_observer">
            Creating an intersection observer
          </a>

          <a href="#section-Intersection_observer_options">
            Intersection observer options
          </a>

          <a href="#section-Targeting_an_element_to_be_observed">
            Targeting an element to be observed
          </a>

          <a href="#section-How_intersection_is_calculated">
            How intersection is calculated
          </a>

          <a href="#section-The_intersection_root_and_root_margin">
            The intersection root and root margin
          </a>

          <a href="#section-Thresholds"> Thresholds </a>

          <a href="#section-Intersection_change_callbacks">
            Intersection change callbacks
          </a>

          <a href="#section-Interfaces"> Interfaces </a>

          <a href="#section-A_simple_example"> A simple example </a>

          <a href="#section-HTML"> HTML </a>

          <a href="#section-CSS"> CSS </a>

          <a href="#section-JavaScript"> JavaScript </a>

          <a href="#section-Setting_up"> Setting up </a>

          <a href="#section-Creating_the_intersection_observer">
            Creating the intersection observer
          </a>

          <a href="#section-Building_the_array_of_threshold_ratios">
            Building the array of threshold ratios
          </a>

          <a href="#section-Handling_intersection_changes">
            Handling intersection changes
          </a>

          <a href="#section-Result"> Result </a>

          <a href="#section-Specifications"> Specifications </a>

          <a href="#section-Browser_compatibility"> Browser compatibility </a>

          <a href="#section-See_also"> See also </a>
        </nav>
      </aside>
      <article class="content" id="wikiArticle">
        <p class="summary">
          <span class="seoSummary"
            >The Intersection Observer API provides a way to asynchronously
            observe changes in the intersection of a target element with an
            ancestor element or with a top-level document's
            <a
              href="/en-US/docs/Glossary/viewport"
              title="viewport: A viewport represents a polygonal (normally rectangular) area in computer graphics that is currently being viewed. In web browser terms, it refers to the part of the document you're viewing which is currently visible in its window (or the screen, if the document is being viewed in full screen mode). Content outside the viewport is not visible onscreen until scrolled into view."
              class="glossaryLink"
              >viewport</a
            >.</span
          >
        </p>
        <p>
          Historically, detecting visibility of an element, or the relative
          visibility of two elements in relation to each other, has been a
          difficult task for which solutions have been unreliable and prone to
          causing the browser and the sites the user is accessing to become
          sluggish. Unfortunately, as the web has matured, the need for this
          kind of information has grown. Intersection information is needed for
          many reasons, such as:
        </p>
        <ul>
          <li>
            Lazy-loading of images or other content as a page is scrolled.
          </li>
          <li>
            Implementing "infinite scrolling" web sites, where more and more
            content is loaded and rendered as you scroll, so that the user
            doesn't have to flip through pages.
          </li>
          <li>
            Reporting of visibility of advertisements in order to calculate ad
            revenues.
          </li>
          <li>
            Deciding whether or not to perform tasks or animation processes
            based on whether or not the user will see the result.
          </li>
        </ul>
        <p>
          Implementing intersection detection in the past involved event
          handlers and loops calling methods like
          <a
            href="/en-US/docs/Web/API/Element/getBoundingClientRect"
            title="The Element.getBoundingClientRect() method returns the size of an element and its position relative to the viewport."
            ><code>Element.getBoundingClientRect()</code></a
          >
          to build up the needed information for every element affected. Since
          all this code runs on the main thread, even one of these can cause
          performance problems. When a site is loaded with these tests, things
          can get downright ugly.
        </p>
        <p>
          Consider a web page that uses infinite scrolling. It uses a
          vendor-provided library to manage the advertisements placed
          periodically throughout the page, has animated graphics here and
          there, and uses a custom library that draws notification boxes and the
          like. Each of these has its own intersection detection routines, all
          running on the main thread. The author of the web site may not even
          realize this is happening, since they're using two libraries that they
          may know very little about the inner workings of. As the user scrolls
          the page, these intersection detection routines are firing constantly
          during the scroll handling code, resulting in an experience that
          leaves the user frustrated with the browser, the web site, and their
          computer.
        </p>
        <p>
          The Intersection Observer API lets code register a callback function
          that is executed whenever an element they wish to monitor enters or
          exits another element (or the
          <a
            href="/en-US/docs/Glossary/viewport"
            title="viewport: A viewport represents a polygonal (normally rectangular) area in computer graphics that is currently being viewed. In web browser terms, it refers to the part of the document you're viewing which is currently visible in its window (or the screen, if the document is being viewed in full screen mode). Content outside the viewport is not visible onscreen until scrolled into view."
            class="glossaryLink"
            >viewport</a
          >), or when the amount by which the two intersect changes by a
          requested amount. This way, sites no longer need to do anything on the
          main thread to watch for this kind of element intersection, and the
          browser is free to optimize the management of intersections as it sees
          fit.
        </p>
        <p>
          One thing the Intersection Observer API can't tell you: the exact
          number of pixels that overlap or specifically which ones they are;
          however, it covers the much more common use case of "If they intersect
          by somewhere around <em>N</em>%, I need to do something."
        </p>

        <section id="section-Intersection_observer_concepts_and_usage">
          <h2 id="Intersection_observer_concepts_and_usage">
            Intersection observer concepts and usage
          </h2>

          <p>
            The Intersection Observer API allows you to configure a callback
            that is called whenever one element, called the
            <strong>target</strong>, intersects either the device viewport or a
            specified element; for the purpose of this API, this is called the
            <strong>root element</strong> or <strong>root</strong>. Typically,
            you'll want to watch for intersection changes with regard to the
            document's viewport (which is done by specifying
            <code>null</code> as the root element ). Whether you're using the
            viewport or some other element as the root, the API works the same
            way, executing a callback function you provide whenever the
            visibility of the target element changes so that it crosses desired
            amounts of intersection with the root.
          </p>

          <p>
            The degree of intersection between the target element and its root
            is the <strong>intersection ratio</strong>. This is a representation
            of the percentage of the target element which is visible as a value
            between 0.0 and 1.0.
          </p>
        </section>

        <section id="section-Creating_an_intersection_observer">
          <h3 id="Creating_an_intersection_observer">
            Creating an intersection observer
          </h3>

          <p>
            Create the intersection observer by calling its constructor and
            passing it a callback function to be run whenever a threshold is
            crossed in one direction or the other:
          </p>

          <pre class="brush: js">
var options = {
  root: document.querySelector('#scrollArea'),
  rootMargin: '0px',
  threshold: 1.0
}

var observer = new IntersectionObserver(callback, options);</pre
          >

          <p>
            A threshold of 1.0 means that when 100% of the target is visible
            within the element specified by the <code>root</code> option, the
            callback is invoked.
          </p>
        </section>

        <section id="section-Intersection_observer_options">
          <h4 id="Intersection_observer_options">
            Intersection observer options
          </h4>

          <p>
            The <code>options</code> object passed into the
            <a
              href="/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver"
              title="The IntersectionObserver() constructor creates and returns a new IntersectionObserver object."
              ><code>IntersectionObserver()</code></a
            >
            constructor let you control the circumstances under which the
            observer's callback is invoked. It has the following fields:
          </p>

          <dl>
            <dt><code>root</code></dt>
            <dd>
              The element that is used as the viewport for checking visiblity of
              the target. Must be the ancestor of the target. Defaults to the
              browser viewport if not specified or if <code>null</code>.
            </dd>
            <dt><code>rootMargin</code></dt>
            <dd>
              Margin around the root. Can have values similar to the CSS
              <a
                href="/en-US/docs/Web/CSS/margin"
                title="The margin CSS property sets the margin area on all four sides of an element. It is a shorthand for setting all individual margins at once: margin-top, margin-right, margin-bottom, and margin-left."
                ><code>margin</code></a
              >
              property, e.g. "<code>10px 20px 30px 40px"</code> (top, right,
              bottom, left). The values can be percentages. This set of values
              serves to grow or shrink each side of the root element's bounding
              box before computing intersections. Defaults to all zeros.
            </dd>
            <dt><code>threshold</code></dt>
            <dd>
              Either a single number or an array of numbers which indicate at
              what percentage of the target's visibility the observer's callback
              should be executed. If you only want to detect when visibility
              passes the 50% mark, you can use a value of 0.5. If you want the
              callback run every time visibility passes another 25%, you would
              specify the array [0, 0.25, 0.5, 0.75, 1]. The default is 0
              (meaning as soon as even one pixel is visible, the callback will
              be run). A value of 1.0 means that the threshold isn't considered
              passed until every pixel is visible.
            </dd>
          </dl>
        </section>

        <section id="section-Targeting_an_element_to_be_observed">
          <h4 id="Targeting_an_element_to_be_observed">
            Targeting an element to be observed
          </h4>

          <p>
            Once you have created the observer, you need to give it a target
            element to watch:
          </p>

          <pre class="brush: js">
var target = document.querySelector('#listItem');
observer.observe(target);
</pre
          >

          <p>
            Whenever the target meets a threshold specified for the
            <code>IntersectionObserver</code>, the callback is invoked. The
            callback receives a list of
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry"
              title="The IntersectionObserverEntry interface of the Intersection Observer API describes the intersection between the target element and its root container at a specific moment of transition."
              ><code>IntersectionObserverEntry</code></a
            >
            objects and the observer:
          </p>

          <pre class="brush: js">
var callback = function(entries, observer) {
  entries.forEach(entry =&gt; {
    // Each entry describes an intersection change for one observed
    // target element:
    //   entry.boundingClientRect
    //   entry.intersectionRatio
    //   entry.intersectionRect
    //   entry.isIntersecting
    //   entry.rootBounds
    //   entry.target
    //   entry.time
  });
};
</pre
          >

          <p>
            Be aware that your callback is executed on the main thread. It
            should operate as quickly as possible; if anything time-consuming
            needs to be done, use
            <a
              href="/en-US/docs/Web/API/Window/requestIdleCallback"
              title="The window.requestIdleCallback() method queues a function to be called during a browser's idle periods. This enables developers to perform background and low priority work on the main event loop, without impacting latency-critical events such as animation and input response. Functions are generally called in first-in-first-out order; however, callbacks which have a timeout specified may be called out-of-order if necessary in order to run them before the timeout elapses."
              ><code>Window.requestIdleCallback()</code></a
            >.
          </p>

          <p>
            Also, note that if you specified the <code>root</code> option, the
            target must be a descendant of the root element.
          </p>
        </section>

        <section id="section-How_intersection_is_calculated">
          <h3 id="How_intersection_is_calculated">
            How intersection is calculated
          </h3>

          <p>
            All areas considered by the Intersection Observer API are
            rectangles; elements which are irregularly shaped are considered as
            occupying the smallest rectangle which encloses all of the element's
            parts. Similarly, if the visible portion of an element is not
            rectangular, the element's intersection rectangle is construed to be
            the smallest rectangle that contains all the visible portions of the
            element.
          </p>

          <p>
            It's useful to understand a bit about how the various properties
            provided by
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry"
              title="The IntersectionObserverEntry interface of the Intersection Observer API describes the intersection between the target element and its root container at a specific moment of transition."
              ><code>IntersectionObserverEntry</code></a
            >
            describe an intersection.
          </p>
        </section>

        <section id="section-The_intersection_root_and_root_margin">
          <h4 id="The_intersection_root_and_root_margin">
            The intersection root and root margin
          </h4>

          <p>
            Before we can track the intersection of an element with a container,
            we need to know what that container is. That container is the
            <strong>intersection root</strong>, or
            <strong>root element</strong>. This can be either an element in the
            document which is an ancestor of the element to be observed, or
            <code>null</code> to use the document's viewport as the container.
          </p>

          <p>
            The rectangle used as the bounds of the intersection root can be
            adjusted by setting the <strong>root margin</strong>,
            <code>rootMargin</code>, when creating the
            <a
              href="/en-US/docs/Web/API/IntersectionObserver"
              title="The IntersectionObserver interface of the Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport."
              ><code>IntersectionObserver</code></a
            >. The values in <code>rootMargin</code> define offsets added to
            each side of the intersection root's bounding box to create the
            final intersection root bounds (which are disclosed in
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry/rootBounds"
              title="The IntersectionObserverEntry interface's read-only rootBounds property is a DOMRectReadOnly corresponding to the target's root intersection rectangle, offset by the IntersectionObserver.rootMargin if one is specified."
              ><code>IntersectionObserverEntry.rootBounds</code></a
            >
            when the callback is executed).
          </p>
        </section>

        <section id="section-Thresholds">
          <h4 id="Thresholds">Thresholds</h4>

          <p>
            Rather than reporting every infinitesimal change in how much a
            target element is visible, the Intersection Observer API uses
            <strong>thresholds</strong>. When you create an observer, you can
            provide one or more numeric values representing percentages of the
            target element which are visible. Then, the API only reports changes
            to visibility which cross these thresholds.
          </p>

          <p>
            For example, if you want to be informed every time a target's
            visibility passes backward or forward through each 25% mark, you
            would specify the array [0, 0.25, 0.5, 0.75, 1] as the list of
            thresholds when creating the observer. You can tell which direction
            the visibility changed in (that is, whether the element became more
            visible or less visible) by checking the value of the
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry/isIntersecting"
              title="The IntersectionObserverEntry interface's read-only isIntersecting property is a Boolean value which is true if the target element intersects with the intersection observer's root. If this is true, then, the IntersectionObserverEntry describes a transition into a state of intersection; if it's false, then you know the transition is from intersecting to not-intersecting."
              ><code>isIntersecting</code></a
            >
            property on the
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry"
              title="The IntersectionObserverEntry interface of the Intersection Observer API describes the intersection between the target element and its root container at a specific moment of transition."
              ><code>IntersectionObserverEntry</code></a
            >
            passed into the callback function at the time of the visibility
            change. If <code>isIntersecting</code> is <code>true</code>, the
            target element has become at least as visible as the threshold that
            was passed. If it's <code>false</code>, the target is no longer as
            visible as the given threshold.
          </p>

          <p>
            To get a feeling for how thresholds work, try scrolling the box
            below around. Each colored box within it displays the percentage of
            itself that's visible in all four of its corners, so you can see
            these ratios change over time as you scroll the container. Each box
            has a different set of thresholds:
          </p>

          <ul>
            <li>
              The first box has a threshold for each percentage point of
              visibility; that is, the
              <a
                href="/en-US/docs/Web/API/IntersectionObserver/thresholds"
                title="The IntersectionObserver interface's read-only thresholds property returns the list of intersection thresholds that was specified when the observer was instantiated with IntersectionObserver(). If only one threshold ratio was provided when instanitating the object, this will be an array containing that single value."
                ><code>IntersectionObserver.thresholds</code></a
              >
              array is <code>[0.00, 0.01, 0.02, ..., 0.99, 1.00]</code>.
            </li>
            <li>The second box has a single threshold, at the 50% mark.</li>
            <li>
              The third box has thresholds every 10% of visibility (0%, 10%,
              20%, etc.).
            </li>
            <li>The last box has thresholds each 25%.</li>
          </ul>

          <div class="hidden" id="threshold-example">
            <pre class="brush: html">
&lt;template id="boxTemplate"&gt;
  &lt;div class="sampleBox"&gt;
    &lt;div class="label topLeft"&gt;&lt;/div&gt;
    &lt;div class="label topRight"&gt;&lt;/div&gt;
    &lt;div class="label bottomLeft"&gt;&lt;/div&gt;
    &lt;div class="label bottomRight"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;main&gt;
  &lt;div class="contents"&gt;
    &lt;div class="wrapper"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/main&gt;</pre
            >

            <pre class="brush: css">
.contents {
  position: absolute;
  width: 700px;
  height: 1725px;
}

.wrapper {
  position: relative;
  top: 600px;
}

.sampleBox {
  position: relative;
  left: 175px;
  width: 150px;
  background-color: rgb(245, 170, 140);
  border: 2px solid rgb(201, 126, 17);
  padding: 4px;
  margin-bottom: 6px;
}

#box1 {
  height: 200px;
}

#box2 {
  height: 75px;
}

#box3 {
  height: 150px;
}

#box4 {
  height: 100px;
}

.label {
  font: 14px "Open Sans", "Arial", sans-serif;
  position: absolute;
  margin: 0;
  background-color: rgba(255, 255, 255, 0.7);
  border: 1px solid rgba(0, 0, 0, 0.7);
  width: 3em;
  height: 18px;
  padding: 2px;
  text-align: center;
}

.topLeft {
  left: 2px;
  top: 2px;
}

.topRight {
  right: 2px;
  top: 2px;
}

.bottomLeft {
  bottom: 2px;
  left: 2px;
}

.bottomRight {
  bottom: 2px;
  right: 2px;
}
</pre
            >

            <pre class="brush: js">
let observers = [];

startup();

function startup() {
  let wrapper = document.querySelector(".wrapper");

  // Options for the observers

  let observerOptions = {
    root: null,
    rootMargin: "0px",
    threshold: []
  };

  // An array of threshold sets for each of the boxes. The
  // first box's thresholds are set programmatically
  // since there will be so many of them (for each percentage
  // point).

  let thresholdSets = [
    [],
    [0.5],
    [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    [0, 0.25, 0.5, 0.75, 1.0]
  ];

  for (let i=0; i&lt;=1.0; i+= 0.01) {
    thresholdSets[0].push(i);
  }

  // Add each box, creating a new observer for each

  for (let i=0; i&lt;4; i++) {
    let template = document.querySelector("#boxTemplate").content.cloneNode(true);
    let boxID = "box" + (i+1);
    template.querySelector(".sampleBox").id = boxID;
    wrapper.appendChild(document.importNode(template, true));

    // Set up the observer for this box

    observerOptions.threshold = thresholdSets[i];
    observers[i] = new IntersectionObserver(intersectionCallback, observerOptions);
    observers[i].observe(document.querySelector("#" + boxID));
  }

  // Scroll to the starting position

  //wrapper.scrollIntoView({
  //  block: "start",
  //});
  document.scrollingElement.scrollTop = wrapper.firstChild.getBoundingClientRect().top + window.scrollY;
  document.scrollingElement.scrollLeft = 750;
}

function intersectionCallback(entries) {
  entries.forEach(function(entry) {
    let box = entry.target;
    let visiblePct = (Math.floor(entry.intersectionRatio * 100)) + "%";

    box.querySelector(".topLeft").innerHTML = visiblePct;
    box.querySelector(".topRight").innerHTML = visiblePct;
    box.querySelector(".bottomLeft").innerHTML = visiblePct;
    box.querySelector(".bottomRight").innerHTML = visiblePct;
  });
}
</pre
            >
          </div>

          <p></p>
        </section>

        <section id="section-Intersection_change_callbacks">
          <h3 id="Intersection_change_callbacks">
            Intersection change callbacks
          </h3>

          <p>
            When the amount of a target element which is visible within the root
            element crosses one of the visibility thresholds,
          </p>
        </section>

        <section id="section-Interfaces">
          <h2 id="Interfaces">Interfaces</h2>

          <dl>
            <dt>
              <a
                href="/en-US/docs/Web/API/IntersectionObserver"
                title="The IntersectionObserver interface of the Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport."
                ><code>IntersectionObserver</code></a
              >
            </dt>
            <dd>
              The primary interface for the Intersection Observer API. Provides
              methods for creating and managing an observer which can watch any
              number of target elements for the same intersection configuration.
              Each observer can asynchronously observe changes in the
              intersection between one or more target elements and a shared
              ancestor element or with their top-level
              <a
                href="/en-US/docs/Web/API/Document"
                title="The Document interface represents any web page loaded in the browser and serves as an entry point into the web page's content, which is the DOM tree."
                ><code>Document</code></a
              >'s
              <a
                href="/en-US/docs/Glossary/viewport"
                title="viewport: A viewport represents a polygonal (normally rectangular) area in computer graphics that is currently being viewed. In web browser terms, it refers to the part of the document you're viewing which is currently visible in its window (or the screen, if the document is being viewed in full screen mode). Content outside the viewport is not visible onscreen until scrolled into view."
                class="glossaryLink"
                >viewport</a
              >. The ancestor or viewport is referred to as the
              <strong>root</strong>.
            </dd>
            <dt>
              <a
                href="/en-US/docs/Web/API/IntersectionObserverEntry"
                title="The IntersectionObserverEntry interface of the Intersection Observer API describes the intersection between the target element and its root container at a specific moment of transition."
                ><code>IntersectionObserverEntry</code></a
              >
            </dt>
            <dd>
              Describes the intersection between the target element and its root
              container at a specific moment of transition. Objects of this type
              can only be obtained in two ways: as an input to your
              <code>IntersectionObserver</code> callback, or by calling
              <a
                href="/en-US/docs/Web/API/IntersectionObserver/takeRecords"
                title="The IntersectionObserver method takeRecords() returns an array of IntersectionObserverEntry objects, one for each targeted element which has experienced an intersection change since the last time the intersections were checked, either explicitly through a call to this method or implicitly by an automatic call to the observer's callback. "
                ><code>IntersectionObserver.takeRecords()</code></a
              >.
            </dd>
          </dl>
        </section>

        <section id="section-A_simple_example">
          <h2 id="A_simple_example">A simple example</h2>

          <p>
            This simple example causes a target element to change its color and
            transparency as it becomes more or less visible. At
            <a
              href="/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility"
              >Timing element visibility with the Intersection Observer API</a
            >, you can find a more extensive example showing how to time how
            long a set of elements (such as ads) are visible to the user and to
            react to that information by recording statistics or by updating
            elements..
          </p>
        </section>

        <section id="section-HTML">
          <h3 id="HTML">HTML</h3>

          <p>
            The HTML for this example is very short, with a primary element
            which is the box that we'll be targeting (with the creative ID
            <code>"box"</code>) and some contents within the box.
          </p>

          <pre class="brush: html">
&lt;div id="box"&gt;
  &lt;div class="vertical"&gt;
    Welcome to &lt;strong&gt;The Box!&lt;/strong&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre
          >
        </section>

        <section id="section-CSS">
          <h3 id="CSS">CSS</h3>

          <p>
            The CSS isn't terribly important for the purposes of this example;
            it lays out the element and establishes that the
            <a
              href="/en-US/docs/Web/CSS/background-color"
              title="The background-color CSS property sets the background color of an element."
              ><code>background-color</code></a
            >
            and
            <a
              href="/en-US/docs/Web/CSS/border"
              title="The border CSS property is a shorthand for setting all individual border property values in a single declaration: border-width, border-style, and border-color."
              ><code>border</code></a
            >
            attributes can participate in
            <a href="/en-US/docs/Web/CSS/CSS_Transitions">CSS transitions</a>,
            which we'll use to affect the changes to the element as it becomes
            more or less obscured.
          </p>

          <pre class="brush: css">
#box {
  background-color: rgba(40, 40, 190, 255);
  border: 4px solid rgb(20, 20, 120);
  transition: background-color 1s, border 1s;
  width: 350px;
  height: 350px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.vertical {
  color: white;
  font: 32px "Arial";
}

.extra {
  width: 350px;
  height: 350px;
  margin-top: 10px;
  border: 4px solid rgb(20, 20, 120);
  text-align: center;
  padding: 20px;
}</pre
          >
        </section>

        <section id="section-JavaScript">
          <h3 id="JavaScript">JavaScript</h3>

          <p>
            Finally, let's take a look at the JavaScript code that uses the
            Intersection Observer API to make things happen.
          </p>
        </section>

        <section id="section-Setting_up">
          <h4 id="Setting_up">Setting up</h4>

          <p>
            First, we need to prepare some variables and install the observer.
          </p>

          <pre class="brush: js">
var numSteps = 20.0;

var boxElement;
var prevRatio = 0.0;
var increasingColor = "rgba(40, 40, 190, ratio)";
var decreasingColor = "rgba(190, 40, 40, ratio)";

// Set things up.

window.addEventListener("load", function(event) {
  boxElement = document.querySelector("#box");

  createObserver();
}, false);</pre
          >

          <p>The constants and variables we set up here are:</p>

          <dl>
            <dt><code>numSteps</code></dt>
            <dd>
              A constant which indicates how many thresholds we want to have
              between a visibility ratio of 0.0 and 1.0.
            </dd>
            <dt><code>prevRatio</code></dt>
            <dd>
              This variable will be used to record what the visibility ratio was
              the last time a threshold was crossed; this will let us figure out
              whether the target element is becoming more or less visible.
            </dd>
            <dt><code>increasingColor</code></dt>
            <dd>
              A string defining a color we'll apply to the target element when
              the visibility ratio is increasing. The word "ratio" in this
              string will be replaced with the target's current visibility
              ratio, so that the element not only changes color but also becomes
              increasingly opaque as it becomes less obscured.
            </dd>
            <dt><code>decreasingColor</code></dt>
            <dd>
              Similarly, this is a string defining a color we'll apply when the
              visibility ratio is decreasing.
            </dd>
          </dl>

          <p>
            We call
            <a
              href="/en-US/docs/Web/API/EventTarget/addEventListener"
              title="The EventTarget method addEventListener() sets up a function to be called whenever the specified event is delivered to the target."
              ><code>Window.addEventListener()</code></a
            >
            to start listening for the
            <code
              ><a
                href="/en-US/docs/Web/Events/load"
                title="/en-US/docs/Web/Events/load"
                >load</a
              ></code
            >
            event; once the page has finished loading, we get a reference to the
            element with the ID <code>"box"</code> using
            <a
              href="/en-US/docs/Web/API/Document/querySelector"
              title="The Document method querySelector() returns the first Element within the document that matches the specified selector, or group of selectors. If no matches are found, null is returned."
              ><code>querySelector()</code></a
            >, then call the <code>createObserver()</code> method we'll create
            in a moment to handle building and installing the intersection
            observer.
          </p>
        </section>

        <section id="section-Creating_the_intersection_observer">
          <h4 id="Creating_the_intersection_observer">
            Creating the intersection observer
          </h4>

          <p>
            The <code>createObserver()</code> method is called once page load is
            complete to handle actually creating the new
            <a
              href="/en-US/docs/Web/API/IntersectionObserver"
              title="The IntersectionObserver interface of the Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport."
              ><code>IntersectionObserver</code></a
            >
            and starting the process of observing the target element.
          </p>

          <pre class="brush: js">
function createObserver() {
  var observer;

  var options = {
    root: null,
    rootMargin: "0px",
    threshold: buildThresholdList()
  };

  observer = new IntersectionObserver(handleIntersect, options);
  observer.observe(boxElement);
}</pre
          >

          <p>
            This begins by setting up an <code>options</code> object containing
            the settings for the observer. We want to watch for changes in
            visibility of the target element relative to the document's
            viewport, so <code>root</code> is <code>null</code>. We need no
            margin, so the margin offset, <code>rootMargin</code>, is specified
            as "0px". This causes the observer to watch for changes in the
            intersection between the target element's bounds and those of the
            viewport, without any added (or subtracted) space.
          </p>

          <p>
            The list of visibility ratio thresholds, <code>threshold</code>, is
            constructed by the function <code>buildThresholdList()</code>. The
            threshold list is built programmatically in this example since there
            are a number of them and the number is intended to be adjustable.
          </p>

          <p>
            Once <code>options</code> is ready, we create the new observer,
            calling the
            <a
              href="/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver"
              title="The IntersectionObserver() constructor creates and returns a new IntersectionObserver object."
              ><code>IntersectionObserver()</code></a
            >
            constructor, specifying a function to be called when intersection
            crosses one of our thresholds, <code>handleIntersect()</code>, and
            our set of options. We then call
            <a
              href="/en-US/docs/Web/API/IntersectionObserver/observe"
              title="The IntersectionObserver method observe() adds an element to the set of target elements being watched by the IntersectionObserver. One observer has one set of thresholds and one root, but can watch multiple target elements for visibility changes in keeping with those."
              ><code>observe()</code></a
            >
            on the returned observer, passing into it the desired target
            element.
          </p>

          <p>
            We could opt to monitor multiple elements for visibility
            intersection changes with respect to the viewport by calling
            <code>observer.observe()</code> for each of those elements, if we
            wanted to do so.
          </p>
        </section>

        <section id="section-Building_the_array_of_threshold_ratios">
          <h4 id="Building_the_array_of_threshold_ratios">
            Building the array of threshold ratios
          </h4>

          <p>
            The <code>buildThresholdList()</code> function, which builds the
            list of thresholds, looks like this:
          </p>

          <pre class="brush: js">
function buildThresholdList() {
  var thresholds = [];

  for (var i=1.0; i&lt;=numSteps; i++) {
    var ratio = i/numSteps;
    thresholds.push(ratio);
  }

  thresholds.push(0);
  return thresholds;
}</pre
          >

          <p>
            This builds the array of thresholds—each of which is a ratio between
            0.0 and 1.0, by pushing the value <code>i/numSteps</code> onto the
            <code>thresholds</code> array for each integer
            <code>i</code> between 1 and <code>numSteps</code>. It also pushes 0
            to include that value. The result, given the default value of
            <code>numSteps</code> (20), is the following list of thresholds:
          </p>

          <table class="standard-table">
            <tbody>
              <tr>
                <th>#</th>
                <th>Ratio</th>
                <th>#</th>
                <th>Ratio</th>
              </tr>
              <tr>
                <th>1</th>
                <td>0.05</td>
                <th>11</th>
                <td>0.55</td>
              </tr>
              <tr>
                <th>2</th>
                <td>0.1</td>
                <th>12</th>
                <td>0.6</td>
              </tr>
              <tr>
                <th>3</th>
                <td>0.15</td>
                <th>13</th>
                <td>0.65</td>
              </tr>
              <tr>
                <th>4</th>
                <td>0.2</td>
                <th>14</th>
                <td>0.7</td>
              </tr>
              <tr>
                <th>5</th>
                <td>0.25</td>
                <th>15</th>
                <td>0.75</td>
              </tr>
              <tr>
                <th>6</th>
                <td>0.3</td>
                <th>16</th>
                <td>0.8</td>
              </tr>
              <tr>
                <th>7</th>
                <td>0.35</td>
                <th>17</th>
                <td>0.85</td>
              </tr>
              <tr>
                <th>8</th>
                <td>0.4</td>
                <th>18</th>
                <td>0.9</td>
              </tr>
              <tr>
                <th>9</th>
                <td>0.45</td>
                <th>19</th>
                <td>0.95</td>
              </tr>
              <tr>
                <th>10</th>
                <td>0.5</td>
                <th>20</th>
                <td>1.0</td>
              </tr>
            </tbody>
          </table>

          <p>
            We could, of course, hard-code the array of thresholds into our
            code, and often that's what you'll end up doing. But this example
            leaves room for adding configuration controls to adjust the
            granularity, for example.
          </p>
        </section>

        <section id="section-Handling_intersection_changes">
          <h4 id="Handling_intersection_changes">
            Handling intersection changes
          </h4>

          <p>
            When the browser detects that the target element (in our case, the
            one with the ID <code>"box"</code>) has been unveiled or obscured
            such that its visibility ratio crosses one of the thresholds in our
            list, it calls our handler function, <code>handleIntersect()</code>:
          </p>

          <pre class="brush: js">
function handleIntersect(entries, observer) {
  entries.forEach(function(entry) {
    if (entry.intersectionRatio &gt; prevRatio) {
      entry.target.style.backgroundColor = increasingColor.replace("ratio", entry.intersectionRatio);
    } else {
      entry.target.style.backgroundColor = decreasingColor.replace("ratio", entry.intersectionRatio);
    }

    prevRatio = entry.intersectionRatio;
  });
}</pre
          >

          <p>
            For each
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry"
              title="The IntersectionObserverEntry interface of the Intersection Observer API describes the intersection between the target element and its root container at a specific moment of transition."
              ><code>IntersectionObserverEntry</code></a
            >
            in the list <code>entries</code>, we look to see if the entry's
            <a
              href="/en-US/docs/Web/API/IntersectionObserverEntry/intersectionRatio"
              title="The IntersectionObserverEntry interface's read-only intersectionRatio property tells you how much of the target element is currently visible within the root's intersection ratio, as a value between 0.0 and 1.0."
              ><code>intersectionRatio</code></a
            >
            is going up; if it is, we set the target's
            <a
              href="/en-US/docs/Web/CSS/background-color"
              title="The background-color CSS property sets the background color of an element."
              ><code>background-color</code></a
            >
            to the string in <code>increasingColor</code> (remember, it's
            <code>"rgba(40, 40, 190, ratio)"</code>), replaces the word "ratio"
            with the entry's <code>intersectionRatio</code>. The result: not
            only does the color get changed, but the transparency of the target
            element changes, too; as the intersection ratio goes down, the
            background color's alpha value goes down with it, resulting in an
            element that's more transparent.
          </p>

          <p>
            Similarly, if the <code>intersectionRatio</code> is going up, we use
            the string <code>decreasingColor</code> and replace the word "ratio"
            in that with the <code>intersectionRatio</code> before setting the
            target element's <code>background-color</code>.
          </p>

          <p>
            Finally, in order to track whether the intersection ratio is going
            up or down, we remember the current ratio in the variable
            <code>prevRatio</code>.
          </p>
        </section>

        <section id="section-Result">
          <h3 id="Result">Result</h3>

          <p>
            Below is the resulting content. Scroll this page up and down and
            notice how the appearance of the box changes as you do so.
          </p>

          <p></p>

          <p>
            There's an even more extensive example at
            <a
              href="/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility"
              >Timing element visibility with the Intersection Observer API</a
            >.
          </p>
        </section>

        <section id="section-Specifications">
          <h2 id="Specifications">Specifications</h2>

          <table class="standard-table">
            <tbody>
              <tr>
                <th scope="col">Specification</th>
                <th scope="col">Status</th>
                <th scope="col">Comment</th>
              </tr>
              <tr>
                <td>
                  <a
                    rel="noopener"
                    hreflang="en"
                    href="https://w3c.github.io/IntersectionObserver/"
                    title="The 'Intersection Observer' specification"
                    class="external"
                    lang="en"
                    >Intersection Observer</a
                  >
                </td>
                <td><span class="spec-WD">Working Draft</span></td>
                <td></td>
              </tr>
            </tbody>
          </table>
        </section>

        <section id="section-Browser_compatibility">
          <h2 id="Browser_compatibility">Browser compatibility</h2>
          <p></p>
          <p class="warning">
            <strong
              ><a
                href="https://github.com/mdn/browser-compat-data"
                class="external"
                rel="noopener"
                >We're converting our compatibility data into a machine-readable
                JSON format</a
              ></strong
            >. This compatibility table still uses the old format, because we
            haven't yet converted the data it contains.
            <strong
              ><a
                href="/en-US/docs/MDN/Contribute/Structures/Compatibility_tables"
                >Find out how you can help!</a
              ></strong
            >
          </p>

          <div class="htab">
            <a id="AutoCompatibilityTable" name="AutoCompatibilityTable"></a>
            <ul>
              <li class="selected"><a>Desktop</a></li>
              <li><a>Mobile</a></li>
            </ul>
          </div>
          <p></p>

          <div id="compat-desktop">
            <table class="compat-table">
              <tbody>
                <tr>
                  <th>Feature</th>
                  <th>Chrome</th>
                  <th>Edge</th>
                  <th>Firefox (Gecko)</th>
                  <th>Internet Explorer</th>
                  <th>Opera</th>
                  <th>Safari (WebKit)</th>
                </tr>
                <tr>
                  <td>Basic support</td>
                  <td>51</td>
                  <td>15</td>
                  <td>
                    <a
                      href="/en-US/Firefox/Releases/55"
                      title="Released on 2017-08-08."
                      >55</a
                    >
                    (55)<sup>[1][2]</sup>
                  </td>
                  <td><span style="color: #f00">No support</span></td>
                  <td>38</td>
                  <td>
                    <a
                      href="https://bugs.webkit.org/show_bug.cgi?id=159475"
                      title=""
                      class="external"
                      rel="external noopener"
                      >WebKit bug 159475</a
                    >
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <div id="compat-mobile">
            <table class="compat-table">
              <tbody>
                <tr>
                  <th>Feature</th>
                  <th>Android Webview</th>
                  <th>Chrome for Android</th>
                  <th>Firefox Mobile (Gecko)</th>
                  <th>Firefox OS</th>
                  <th>IE Mobile</th>
                  <th>Opera Mobile</th>
                  <th>Safari Mobile</th>
                </tr>
                <tr>
                  <td>Basic support</td>
                  <td>51</td>
                  <td>51</td>
                  <td>55.0 (55)<sup>[1][2]</sup></td>
                  <td><span style="color: #f00">No support</span></td>
                  <td><span style="color: #f00">No support</span></td>
                  <td>38</td>
                  <td>
                    <a
                      href="https://bugs.webkit.org/show_bug.cgi?id=159475"
                      title=""
                      class="external"
                      rel="external noopener"
                      >WebKit bug 159475</a
                    >
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>
            [1] This feature has been implemented since Gecko 53.0 (Firefox 53.0
            / Thunderbird 53.0 / SeaMonkey 2.50) behind the preference
            <code>dom.IntersectionObserver.enabled</code>, which was
            <code>false</code> by default. Enabled by default beginning in
            Firefox 55. See
            <a
              href="https://bugzilla.mozilla.org/show_bug.cgi?id=1243846"
              title="FIXED: Implement Intersection Observer API"
              class="external"
              rel="noopener"
              >bug 1243846</a
            >.
          </p>

          <p>
            [2] Firefox doesn't currently take the
            <a
              href="/en-US/docs/Web/CSS/clip-path"
              title="The clip-path CSS property creates a clipping region that defines what part of an element should be displayed. More specifically, those portions that are inside the region are shown, while those outside are hidden."
              ><code>clip-path</code></a
            >
            of ancestor elements into account when computing the visibility of
            an element within its root. See
            <a
              href="https://bugzilla.mozilla.org/show_bug.cgi?id=1319140"
              title="(intersection-observer) Take clip-path into account"
              class="external"
              rel="noopener"
              >bug 1319140</a
            >
            for the status of this issue.
          </p>
        </section>

        <section id="section-See_also">
          <h2 id="See_also">See also</h2>

          <ul>
            <li>
              <a
                href="https://github.com/w3c/IntersectionObserver"
                class="external"
                rel="noopener"
                >Intersection Observer polyfill</a
              >
            </li>
            <li>
              <a
                href="/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility"
                >Timing element visibility with the Intersection Observer API</a
              >
            </li>
            <li>
              <a
                href="/en-US/docs/Web/API/IntersectionObserver"
                title="The IntersectionObserver interface of the Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport."
                ><code>IntersectionObserver</code></a
              >
              and
              <a
                href="/en-US/docs/Web/API/IntersectionObserverEntry"
                title="The IntersectionObserverEntry interface of the Intersection Observer API describes the intersection between the target element and its root container at a specific moment of transition."
                ><code>IntersectionObserverEntry</code></a
              >
            </li>
          </ul>
        </section>
      </article>
    </main>
  </body>
</html>
